import clava.stats.OpsCost;

/**
 * @class
 */
var OpsBlock = function (id) {
	this.id = id;
	this.cost = new OpsCost();
	this.nestedOpsBlocks = [];
	this.repetitions = 1;
	//this.isRecursive = false;
};

OpsBlock.prototype.toString = function () {
	return object2stringSimple(this);
}

OpsBlock.prototype.add = function (primitiveType, bitWidth, opType) {
	this.cost.increment(primitiveType, bitWidth, opType);
}

/**
 * Reduces this block of operations and all nested blocks into a single one,
 * considering the number of repetitions of each block.
 * 
 * E.g.
 * ```
 * {
 * 	"iops-32-add": 5,
 * 	"iops-32-mul": 3 ,
 * 	"flops-64-mul": 2048,
 * 	"flops-64-add": 2048
 * }
 * ```
 * 
 * @returns {Object.<String,Number>} A plain object with the number of
 * operations per operation type (grouped by primitive type, bitwidth and
 * operator name, see {@link OpsCost.buildKey}).
 */
OpsBlock.prototype.__reduce = function () {
	if (this.cost.ops === undefined || this.cost.ops === null)
		return acc;

	/**
	 * 
	 * @param {Object} acc 
	 * @param {Object.<String, Number>} opsCost 
	 * @param {Number} reps
	 */
	var genericReduce = (acc, opsCost, reps) => {
		// for each key
		for (var key in opsCost) {
			// make any initialization if needed
			if (acc[key] === undefined)
				acc[key] = 0;

			// operations occur `reps` times
			acc[key] += opsCost[key] * reps;
		}
	};

	// init
	var acc = {};

	// reduce this block operations
	genericReduce(acc, this.cost.ops, this.repetitions);

	// reduce all nested blocks
	for (var nestedBlock of this.nestedOpsBlocks) {
		var nestedAcc = nestedBlock.__reduce();
		genericReduce(acc, nestedAcc, this.repetitions);
	}

	return acc;
}

/**
 * Reduces the operations grouping them by their primitive type and bitwidth
 * 
 * E.g.
 * ```
 * {
 * 	"iops-32": 8,
 * 	"flops-64": 4096,
 * }
 * ```
 * 
 * @param {Object} acc The accumulator object, and final return value
 * @param {Number} numOps The number of counted operations for the tuple
 * (primitiveType, opName, bitWidth)
 * @param {"iops"|"flops"} primitiveType The primitive type of the operation,
 * i.e. integer or floating-point
 * @param {String} opName The operator name, e.g. `add`, `assing`, etc. See
 * {@link StaticOpsCounter._validOps}
 * @param {8|16|32|64} bitWidth The operation data type size in bits
 */
OpsBlock.__defaultReduce = function (acc, numOps, primitiveType, opName, bitWidth) {
	var key = primitiveType + '-' + bitWidth;
	if (acc[key] === undefined) {
		acc[key] = 0;
	}

	acc[key] += numOps;
};

/**
 * 
 * @param {Object} [acc={}] The accumulator object, controlled by the
 * user-defined reducer
 * @param {Function} [reducer=OpsBlock.__defaultReduce] The user-defined
 * reducer function. See {@link OpsBlock.__defaultReduce} for expected function
 * signature
 * 
 * @returns {Object} The reduced operations block object
 */
OpsBlock.prototype.reduce = function (acc, reducer) {
	// if no user-defined reducer, fallback to a default
	if (reducer === undefined) {
		reducer = OpsBlock.__defaultReduce;
		acc = {};
	}

	// perform normal reduce
	var __acc = this.__reduce();

	// aggregate the data as defined by the user's reducer
	for (var key in __acc) {
		// extract the primitive data type, bitwidth and operator name
		var objKey = OpsCost.splitKey(key);
		// invoke users reduce operation
		reducer(
			acc,
			__acc[key],
			objKey.primitiveType,
			objKey.opName,
			objKey.bitWidth
		);
	}

	return acc;
}
