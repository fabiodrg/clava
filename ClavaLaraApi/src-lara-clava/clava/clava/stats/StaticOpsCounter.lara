import clava.ClavaJoinPoints;
import clava.code.GlobalVariable;
import clava.stats.OpsBlock;

import weaver.Query;

import lara.util.StringSet;
import lara.util.PrintOnce;
import lara.code.Logger;

import lara.Strings;

/**
 * @class
 * Counts total operations in a region of code
 *
 * @param {function?} filterFunction Function that receives an $op. If returns
 * false, $op will not be counted.
 * @param {Object} config 
 * @param {Boolean} [config.inclLoopHeader=false] Include operations in loop
 * headers
 * @param {Boolean} [config.inclArraySubscript=true] Include operations in array
 * subscript expressions
 */
var StaticOpsCounter = function (filterFunction, config) {
	/**
	 * Stores processed functions (cache)
	 */
	this.instrumentedFunctions = {};
	/**
	 * User-defined filter
	 */
	this._filterFunction = filterFunction;
	/**
	 * User settings
	 */
	this.inclLoopHeader = (config && config.inclLoopHeader) || false;
	this.inclArraySubscript = (config && config.inclArraySubscript) || true;
};

/**
 * The valid operators names in Clava
 */
StaticOpsCounter._validOps = new StringSet(
	"mul",
	"div",
	"rem",
	"add",
	"sub",
	"shl",
	"shr",
	"cmp",
	"and",
	"xor",
	"or",
	"l_and",
	"l_or",
	"mul_assign",
	"div_assign",
	"rem_assign",
	"add_assign",
	"sub_assign",
	"shl_assign",
	"shr_assign",
	"and_assign",
	"xor_assign",
	"or_assign",
	"post_inc",
	"post_dec",
	"pre_inc",
	"pre_dec"
);

StaticOpsCounter.prototype.count = function ($jp, opsBlock) {
	if ($jp.joinPointType === "function") {
		// process this function jp
		return this.__count$function($jp, opsBlock);
	} else if ($jp.joinPointType === "loop") {
		// process this loop jp
		return this.__count$loop($jp, opsBlock);
	} else if ($jp.instanceOf("expression")) {
		// if there's no block yet, create a new empty one
		if (opsBlock === undefined) {
			opsBlock = new OpsBlock(this.__getOpsBlockId($jp));
		}
		return this.__count$expr($jp, opsBlock);
	} else {
		// unknown type, create a block if needed and traverse the children nodes

		if (opsBlock === undefined) {
			opsBlock = new OpsBlock(this.__getOpsBlockId($jp));
		}
		for (var $child of $jp.children) {
			this.count($child, opsBlock);
		}
		return opsBlock;
	}
}

StaticOpsCounter.prototype.__count$expr = function ($expr, opsBlock) {
	if (!$expr.instanceOf("expression")) {
		throw new Error("Expected $expression joinpoint, got :" + $expr);
	}

	// if array subscript disabled and expression is array access, skip it
	if (!this.inclArraySubscript && $expr.instanceOf("arrayAccess")) {
		return OpsBlock;
	}

	// process this expression type
	if ($expr.instanceOf("op")) {
		var $op = $expr;

		// cound if valid
		if (this._isValidOp($op)) {
			// Calculate type and bitwidth
			var $builtinType = this._toBuiltinType($op.type);
			var counterType = this._getCounterType($builtinType);
			var bitwidth = $builtinType !== undefined ? $builtinType.bitWidth($op) : undefined;

			// Increment counter
			opsBlock.add(counterType, bitwidth, $op.kind);
		}

	} else if ($expr.instanceOf("call")) {
		var $funcDef = $expr.definition;
		// count function operations if defined
		if ($funcDef !== undefined) {
			this.count($funcDef, opsBlock);
		}
	}

	// traverse children nodes
	for (var $child of $expr.children) {
		this.count($child, opsBlock);
	}

	return opsBlock;
}

StaticOpsCounter.prototype.__count$loop = function ($loop, opsBlock) {
	if (!$loop.instanceOf("loop"))
		throw new Error("Expected $loop joinpoint, got :" + $loop);

	if ($loop.kind !== "for") {
		println("Ignoring loops that are not 'fors' (location " + $loop.location + ") for now");
		return;
	}

	// Create block for loop
	var loopBlock = new OpsBlock(this.__getOpsBlockId($loop));

	// Push it to nested blocks
	if (opsBlock !== undefined) {
		opsBlock.nestedOpsBlocks.push(loopBlock);
	}

	// Extract iterations
	loopBlock.repetitions = $loop.iterationsExpr.code;

	// go statement-by-statement
	// if header is included, traverse all direct children, which includes
	// init stmt, cond stmt, step stmt and the loop body
	// otherwise, skip to loop body
	if (!this.inclLoopHeader) {
		println("disabled");
		this.count($loop.body, loopBlock);
	} else {
		println("enabled");
		for (var $stmt of $loop.children) {
			this.count($stmt, loopBlock);
		}
	}

	return loopBlock;
}

StaticOpsCounter.prototype.__count$function = function ($function, opsBlock) {
	if (!$function.instanceOf("function")) {
		throw new Error("Expected $function joinpoint, got :" + $function);
	}

	// Build function ID
	var functionId = this.__getOpsBlockId($function);

	// Create block for function or use a cached version
	var functionBlock;
	if (functionId in this.instrumentedFunctions) {
		functionBlock = this.instrumentedFunctions[functionId];
	} else {
		functionBlock = new OpsBlock(functionId);
		this.instrumentedFunctions[functionId] = functionBlock;
	}

	// Push it to nested blocks
	if (opsBlock !== undefined) {
		opsBlock.nestedOpsBlocks.push(functionBlock);
	}

	// Go statement-by-statement
	for (var $stmt of $function.body.children) {
		this.count($stmt, functionBlock);
	}

	return functionBlock;
}

StaticOpsCounter.prototype.__getOpsBlockId = function ($jp) {
	if ($jp.instanceOf("function")) {
		return $jp.name + "@" + $jp.location;
	} else if ($jp.instanceOf("loop")) {
		var $parentFunc = $jp.ancestor("function");
		var str = $parentFunc !== null ? $parentFunc.name + ":" : "";
		return str + "loop:" + $jp.rank.join('-') + "@" + $jp.location;
	} else {
		var $parentFunc = $jp.ancestor("function");
		var str = $parentFunc !== null ? $parentFunc.name + ":" : "";
		return str + $jp.joinPointType + "@" + $jp.location;
	}
}

StaticOpsCounter.prototype._getCounterType = function ($builtinType) {

	if ($builtinType === undefined) {
		return undefined;
	}

	if ($builtinType.isFloat) {
		return "flops";
	} else if ($builtinType.isInteger) {
		return "iops";
	} else {
		PrintOnce.message("StaticOpsCounter: could not determine if builtinType " + $type.kind + " is integer or float");
		return undefined;
	}
}

StaticOpsCounter.prototype._toBuiltinType = function ($type) {
	// try to desugar this type until a builtin type is found
	if ($type.hasSugar) {
		$type = $type.desugarAll;
	}

	if ($type.instanceOf("builtinType")) {
		return $type;
	}

	PrintOnce.message("StaticOpsCounter: could not determine builtinType of " + $type.joinPointType);
	return undefined;
}


StaticOpsCounter.prototype._isValidOp = function ($op) {
	var isValid = StaticOpsCounter._validOps.has($op.kind);

	if (!isValid) {
		return false;
	}

	if (this._filterFunction !== undefined) {
		// call filter function
		return this._filterFunction($op);
	}

	return true;
}