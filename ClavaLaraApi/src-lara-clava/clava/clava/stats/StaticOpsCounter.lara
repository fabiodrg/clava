import clava.ClavaJoinPoints;
import clava.code.GlobalVariable;
import clava.stats.OpsBlock;

import weaver.Query;

import lara.util.StringSet;
import lara.util.PrintOnce;
import lara.code.Logger;

import lara.Strings;

/**
 * @class
 * Counts total operations in a region of code
 *
 * @param {function?} [filterFunction] Function that receives an $op. If returns
 * false, $op will not be counted.
 */
var StaticOpsCounter = function (filterFunction) {
	/**
	 * Stores processed functions (cache)
	 */
	this.instrumentedFunctions = {};
	/**
	 * User-defined filter
	 */
	this._filterFunction = filterFunction;
};

/**
 * The valid operators names in Clava
 */
StaticOpsCounter._validOps = new StringSet(
	"mul",
	"div",
	"rem",
	"add",
	"sub",
	"shl",
	"shr",
	"cmp",
	"and",
	"xor",
	"or",
	"l_and",
	"l_or",
	"mul_assign",
	"div_assign",
	"rem_assign",
	"add_assign",
	"sub_assign",
	"shl_assign",
	"shr_assign",
	"and_assign",
	"xor_assign",
	"or_assign",
	"post_inc",
	"post_dec",
	"pre_inc",
	"pre_dec"
);

StaticOpsCounter.prototype.count = function ($jp, opsBlock) {
	if ($jp.joinPointType === "function") {
		// process this function jp
		return this.__count$function($jp, opsBlock);
	} else if ($jp.joinPointType === "loop") {
		// process this loop jp
		return this.__count$loop($jp, opsBlock);
	} else if ($jp.instanceOf("statement")) {
		// if there's no block yet, create a new empty one
		if (opsBlock === undefined) {
			opsBlock = new OpsBlock(this.__getOpsBlockId($jp));
		}
		return this.__count$stmt($jp, opsBlock);
	} else {
		println("Unknown " + $jp);
	}
}

StaticOpsCounter.prototype.__count$stmt = function ($stmt, opsBlock) {
	if (!$stmt.instanceOf("statement")) {
		throw new Error("Expected $statement joinpoint, got :" + $stmt);
	}

	// If stmt is not a loop, count ops
	// Apply to all ops found in the stmt
	for (var $op of Query.searchFrom($stmt, 'op')) {

		// If not a valid op, continue
		if (!this._isValidOp($op)) {
			continue;
		}

		// Calculate type and bitwidth
		var $builtinType = this._toBuiltinType($op.type);
		var counterType = this._getCounterType($builtinType);
		var bitwidth = $builtinType !== undefined ? $builtinType.bitWidth($op) : undefined;

		// Increment counter
		opsBlock.add(counterType, bitwidth, $op.kind);
	}

	// Call function recursively when function calls are found
	for (var $call of Query.searchFrom($stmt, 'call')) {
		var $funcDef = $call.definition;
		if ($funcDef === undefined) {
			continue;
		}
		// count operations for this function
		this.count($funcDef, opsBlock);
	}

	return opsBlock;
}

StaticOpsCounter.prototype.__count$loop = function ($loop, opsBlock) {
	if (!$loop.instanceOf("loop"))
		throw new Error("Expected $loop joinpoint, got :" + $loop);

	if ($loop.kind !== "for") {
		println("Ignoring loops that are not 'fors' (location " + $loop.location + ") for now");
		return;
	}

	// Create block for loop
	var loopBlock = new OpsBlock(this.__getOpsBlockId($loop));

	// Push it to nested blocks
	if (opsBlock !== undefined) {
		opsBlock.nestedOpsBlocks.push(loopBlock);
	}

	// Extract iterations
	loopBlock.repetitions = $loop.iterationsExpr.code;

	// Go statement-by-statement
	for (var $stmt of $loop.body.children) {
		this.count($stmt, loopBlock);
	}

	return loopBlock;
}

StaticOpsCounter.prototype.__count$function = function ($function, opsBlock) {
	if (!$function.instanceOf("function")) {
		throw new Error("Expected $function joinpoint, got :" + $function);
	}

	// Create block for function
	var functionBlock = new OpsBlock(this.__getOpsBlockId($function));

	// Push it to nested blocks
	if (opsBlock !== undefined) {
		opsBlock.nestedOpsBlocks.push(functionBlock);
	}

	// Go statement-by-statement
	for (var $stmt of $function.body.children) {
		this.count($stmt, functionBlock);
	}

	return functionBlock;
}

StaticOpsCounter.prototype.__getOpsBlockId = function ($jp) {
	if ($jp.instanceOf("function")) {
		return $jp.name + "@" + $jp.location;
	} else if ($jp.instanceOf("loop")) {
		var $parentFunc = $jp.ancestor("function");
		var str = $parentFunc !== null ? $parentFunc.name + ":" : "";
		return str + "loop:" + $jp.rank.join('-') + "@" + $jp.location;
	} else {
		var $parentFunc = $jp.ancestor("function");
		var str = $parentFunc !== null ? $parentFunc.name + ":" : "";
		return str + $jp.joinPointType + "@" + $jp.location;
	}
}

StaticOpsCounter.prototype._getCounterType = function ($builtinType) {

	if ($builtinType === undefined) {
		return undefined;
	}

	if ($builtinType.isFloat) {
		return "flops";
	} else if ($builtinType.isInteger) {
		return "iops";
	} else {
		PrintOnce.message("StaticOpsCounter: could not determine if builtinType " + $type.kind + " is integer or float");
		return undefined;
	}
}

StaticOpsCounter.prototype._toBuiltinType = function ($type) {
	// try to desugar this type until a builtin type is found
	if ($type.hasSugar) {
		$type = $type.desugarAll;
	}

	if ($type.instanceOf("builtinType")) {
		return $type;
	}

	PrintOnce.message("StaticOpsCounter: could not determine builtinType of " + $type.joinPointType);
	return undefined;
}


StaticOpsCounter.prototype._isValidOp = function ($op) {
	var isValid = StaticOpsCounter._validOps.has($op.kind);

	if (!isValid) {
		return false;
	}

	// Ignore operations inside loop headers
	if ($op.isInsideLoopHeader) {
		return false;
	}

	//println("FILTER FUNCTION DEFINED? " + (this._filterFunction !== undefined));
	if (this._filterFunction !== undefined) {
		//println("Calling filter function");
		if (!this._filterFunction($op)) {
			return false;
		}
	}

	return true;
}